/* -*- mode: C++; indent-tabs-mode: nil; -*-
 *
 * This file is a part of LEMON, a generic C++ optimization library.
 *
 * Copyright (C) 2003-2008
 * Egervary Jeno Kombinatorikus Optimalizalasi Kutatocsoport
 * (Egervary Research Group on Combinatorial Optimization, EGRES).
 *
 * Permission to use, modify and distribute this software is granted
 * provided that this copyright notice appears in all copies. For
 * precise terms see the accompanying LICENSE file.
 *
 * This software is provided "AS IS" with no warranty of any kind,
 * express or implied, and with no claim as to its suitability for any
 * purpose.
 *
 */

/**
@defgroup datas Data Structures
This group describes the several data structures implemented in LEMON.
*/

/**
@defgroup graphs Graph Structures
@ingroup datas
\brief Graph structures implemented in LEMON.

The implementation of combinatorial algorithms heavily relies on
efficient graph implementations. LEMON offers data structures which are
planned to be easily used in an experimental phase of implementation studies,
and thereafter the program code can be made efficient by small modifications.

The most efficient implementation of diverse applications require the
usage of different physical graph implementations. These differences
appear in the size of graph we require to handle, memory or time usage
limitations or in the set of operations through which the graph can be
accessed.  LEMON provides several physical graph structures to meet
the diverging requirements of the possible users.  In order to save on
running time or on memory usage, some structures may fail to provide
some graph features like arc/edge or node deletion.

You are free to use the graph structure that fit your requirements
the best, most graph algorithms and auxiliary data structures can be used
with any graph structure.

<b>See also:</b> \ref graph_concepts "Graph Structure Concepts".
*/

/**
@defgroup maps Maps
@ingroup datas
\brief Map structures implemented in LEMON.

This group describes the map structures implemented in LEMON.

LEMON provides several special purpose maps and map adaptors that e.g. combine
new maps from existing ones.

<b>See also:</b> \ref map_concepts "Map Concepts".
*/

/**
@defgroup graph_maps Graph Maps
@ingroup maps
\brief Special graph-related maps.

This group describes maps that are specifically designed to assign
values to the nodes and arcs of graphs.
*/

/**
\defgroup map_adaptors Map Adaptors
\ingroup maps
\brief Tools to create new maps from existing ones

This group describes map adaptors that are used to create "implicit"
maps from other maps.

Most of them are \ref lemon::concepts::ReadMap "read-only maps".
They can make arithmetic and logical operations between one or two maps
(negation, shifting, addition, multiplication, logical 'and', 'or',
'not' etc.) or e.g. convert a map to another one of different Value type.

The typical usage of this classes is passing implicit maps to
algorithms.  If a function type algorithm is called then the function
type map adaptors can be used comfortable. For example let's see the
usage of map adaptors with the \c graphToEps() function.
\code
  Color nodeColor(int deg) {
    if (deg >= 2) {
      return Color(0.5, 0.0, 0.5);
    } else if (deg == 1) {
      return Color(1.0, 0.5, 1.0);
    } else {
      return Color(0.0, 0.0, 0.0);
    }
  }

  Digraph::NodeMap<int> degree_map(graph);

  graphToEps(graph, "graph.eps")
    .coords(coords).scaleToA4().undirected()
    .nodeColors(composeMap(functorToMap(nodeColor), degree_map))
    .run();
\endcode
The \c functorToMap() function makes an \c int to \c Color map from the
\c nodeColor() function. The \c composeMap() compose the \c degree_map
and the previously created map. The composed map is a proper function to
get the color of each node.

The usage with class type algorithms is little bit harder. In this
case the function type map adaptors can not be used, because the
function map adaptors give back temporary objects.
\code
  Digraph graph;

  typedef Digraph::ArcMap<double> DoubleArcMap;
  DoubleArcMap length(graph);
  DoubleArcMap speed(graph);

  typedef DivMap<DoubleArcMap, DoubleArcMap> TimeMap;
  TimeMap time(length, speed);

  Dijkstra<Digraph, TimeMap> dijkstra(graph, time);
  dijkstra.run(source, target);
\endcode
We have a length map and a maximum speed map on the arcs of a digraph.
The minimum time to pass the arc can be calculated as the division of
the two maps which can be done implicitly with the \c DivMap template
class. We use the implicit minimum time map as the length map of the
\c Dijkstra algorithm.
*/

/**
@defgroup paths Path Structures
@ingroup datas
\brief Path structures implemented in LEMON.

This group describes the path structures implemented in LEMON.

LEMON provides flexible data structures to work with paths.
All of them have similar interfaces and they can be copied easily with
assignment operators and copy constructors. This makes it easy and
efficient to have e.g. the Dijkstra algorithm to store its result in
any kind of path structure.

\sa lemon::concepts::Path
*/

/**
@defgroup auxdat Auxiliary Data Structures
@ingroup datas
\brief Auxiliary data structures implemented in LEMON.

This group describes some data structures implemented in LEMON in
order to make it easier to implement combinatorial algorithms.
*/

/**
@defgroup algs Algorithms
\brief This group describes the several algorithms
implemented in LEMON.

This group describes the several algorithms
implemented in LEMON.
*/

/**
@defgroup search Graph Search
@ingroup algs
\brief Common graph search algorithms.

This group describes the common graph search algorithms like
Breadth-First Search (BFS) and Depth-First Search (DFS).
*/

/**
@defgroup shortest_path Shortest Path Algorithms
@ingroup algs
\brief Algorithms for finding shortest paths.

This group describes the algorithms for finding shortest paths in graphs.
*/

/**
@defgroup spantree Minimum Spanning Tree Algorithms
@ingroup algs
\brief Algorithms for finding a minimum cost spanning tree in a graph.

This group describes the algorithms for finding a minimum cost spanning
tree in a graph
*/

@ingroup algs
/**
@defgroup utils Tools and Utilities
\brief Tools and utilities for programming in LEMON

Tools and utilities for programming in LEMON.
*/

/**
@defgroup gutils Basic Graph Utilities
@ingroup utils
\brief Simple basic graph utilities.

This group describes some simple basic graph utilities.
*/

/**
@defgroup misc Miscellaneous Tools
@ingroup utils
\brief Tools for development, debugging and testing.

This group describes several useful tools for development,
debugging and testing.
*/

/**
@defgroup timecount Time Measuring and Counting
@ingroup misc
\brief Simple tools for measuring the performance of algorithms.

This group describes simple tools for measuring the performance
of algorithms.
*/

/**
@defgroup exceptions Exceptions
@ingroup utils
\brief Exceptions defined in LEMON.

This group describes the exceptions defined in LEMON.
*/

/**
@defgroup io_group Input-Output
\brief Graph Input-Output methods

This group describes the tools for importing and exporting graphs
and graph related data. Now it supports the LEMON format
and the encapsulated postscript (EPS) format.
postscript (EPS) format.
*/

/**
@defgroup lemon_io LEMON Input-Output
@ingroup io_group
\brief Reading and writing LEMON Graph Format.

This group describes methods for reading and writing
\ref lgf-format "LEMON Graph Format".
*/

/**
@defgroup eps_io Postscript Exporting
@ingroup io_group
\brief General \c EPS drawer and graph exporter

This group describes general \c EPS drawing methods and special
graph exporting tools.
*/

/**
@defgroup concept Concepts
\brief Skeleton classes and concept checking classes

This group describes the data/algorithm skeletons and concept checking
classes implemented in LEMON.

The purpose of the classes in this group is fourfold.

- These classes contain the documentations of the concepts. In order
  to avoid document multiplications, an implementation of a concept
  simply refers to the corresponding concept class.

- These classes declare every functions, <tt>typedef</tt>s etc. an
  implementation of the concepts should provide, however completely
  without implementations and real data structures behind the
  interface. On the other hand they should provide nothing else. All
  the algorithms working on a data structure meeting a certain concept
  should compile with these classes. (Though it will not run properly,
  of course.) In this way it is easily to check if an algorithm
  doesn't use any extra feature of a certain implementation.

- The concept descriptor classes also provide a <em>checker class</em>
  that makes it possible to check whether a certain implementation of a
  concept indeed provides all the required features.

- Finally, They can serve as a skeleton of a new implementation of a concept.
*/

/**
@defgroup graph_concepts Graph Structure Concepts
@ingroup concept
\brief Skeleton and concept checking classes for graph structures

This group describes the skeletons and concept checking classes of LEMON's
graph structures and helper classes used to implement these.
*/


This group describes the skeletons and concept checking classes of maps.
/**
\anchor demoprograms

@defgroup demos Demo programs

Some demo programs are listed here. Their full source codes can be found in
the \c demo subdirectory of the source tree.

It order to compile them, use <tt>--enable-demo</tt> configure option when
build the library.
*/
